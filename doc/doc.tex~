\documentclass[a4paper,12pt]{article}
\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{indentfirst}
%\usepackage[alf]{bntcite}
%\usepackage{abntex-abrev}
\usepackage{geometry}
\geometry{a4paper,left=2.3cm,right=2.3cm,top=2.3cm,bottom=2.3cm}

\begin{document}

\selectlanguage{brazil}
\sloppy

%%%%%%%%%% titulo
\begin{center}
\hrule
\vspace{0.4cm}
{\small Universidade Federal de Minas Gerais \\
Ciência da Computação \\
}
\vspace{0.4cm}
{\Large {\bf TP2: Comunidades em Grafos}\\ {\large Projeto e Análise de Algoritmos}\\} 
 \vspace{0.6cm}
{\normalsize {\bf Lucas Cunha de Oliveira Miranda}\\{\small lucmir@dcc.ufmg.br}}
\end{center}


\hrule
\vspace{0.2cm}

\section{Proposta}

O Trabalho Prático propõe a implementação e análise de algoritmos para busca de comunidades em grafos. 
Uma comunidade é um subconjunto de vértices que apresentam ligações mais densas.
Os algoritmos implementados devem ser baseados no conceito de {\it centralidade} de uma aresta.
A centralidade de uma aresta correponde ao número de caminhos mínimos que passam por ela.
Os algoritmos para obtenção de caminhos mínimos {\it BFS} e {\it Floyd-Warshall} devem ser implementados como parte da solução.

\section{Solução}

O problema de encontrar comunidades em grafos foi solucionado pelo uso de um método inspirado no trabalho de {\it Girvan Newman} \cite{girvannewman}.
O {\it Algoritmo de Girvan Newman} é um método proposto para detecção de comunidades em redes (grafos).
Uma comunidade consiste em um subconjunto de nodos ligados por uma densidade grande de arestas.
O método usado é baseado no conceito de centralidade ({\it betweenness}). %cite
Para uma aresta $i$, a {\it centralidade} é definida como o número de caminhos mínimos entre pares de vértices que passam por $i$.
A {\it centralidade} de uma aresta é uma métrica que indica sua influência na estrutura da rede.
Com base nesta ideia, o algoritmo de {\it Givan Newman} propõe uma abordagem iterativa para detectar comunidades.
Primeiramente, calcula-se a {\it centralidade} de cada aresta. Em seguida, a aresta com maior valor da métrica calculada é removida.
Após a remoção, verifica-se o número de comunidades existentes na nova configuração do grafo.
O processo é repetido sucessivamente, recalculando os valores de {\it centralidade} e removendo arestas, até que o grafo resultante contenha o número de comunidades desejado.

O algoritmo \ref{algoritmo1} resume a solução detalhada.

\begin{algorithm}[!h]
\begin{small}
 \caption{Método baseado no Algoritmo de {\it Girvan Newman}}
 	\begin{algorithmic}[1]
        \STATE calcule centralidade para todas as arestas do grafo
	\WHILE{número de comunidades no grafo é igual ao desejado}
	      \STATE remova aresta com maior centralidade
	      \STATE recalcule a centralidade para arestas afetadas
        \ENDWHILE
        \RETURN comunidades do grafo
 	\end{algorithmic}
\label{algoritmo1} 
\end{small}
\end{algorithm}

O grafo foi representado e implementado usando a estrutura de dados lista de adjascência, onde cada vértice da lista contém uma lista associada com os identificadores dos vértices com os quais são formadas arestas.

Foram feitas duas implementações do algoritmo de {\it Girvan Newman}. As implementações seguiram o algoritmo \ref{algoritmo1}, variando apenas o método para cálculo dos caminhos mínimos 
(necessário para determinar a centralidade das arestas). Foram adotados os algoritmos para obtenção de caminhos mínimos {\it Breadth First Search} e {\it Floyd Warshall}.

\subsection{Solução por {\it Breadth First Search}}

{\it Breadth First Search} (ou {\it busca em largura}), em teoria de grafos, é um algoritmo para execução de buscas em árvores \cite{bfsa}. 
O método expande e examina sistematicamente todos os nós da árvore. 
Todos os nós filhos obtidos pela expansão de um nó são adicionados a uma fila (FIFO).
Os nós examinados são retirados da fila e marcados.
O algoritmo é aplicado para obtenção do caminho mínimo entre pares de vértices, como detalhado no algoritmo \ref{algoritmo2}.

\begin{algorithm}[!h]
\begin{small}
 \caption{Algoritmo {\it Breadth First Search}}
 	\begin{algorithmic}[1]
	\STATE escolha uma raiz $s$ de $G$
	\STATE marque $s$
	\STATE insira $s$ na fila $F$
	\WHILE {$F$ não está vazia faça}
      		\STATE seja $v$ o primeiro vértice de $F$
		\FOR{$w \in$ listaDeAdjacência de $v$}
		        \IF{$w$ não está marcado então}
		            \STATE visite aresta entre $v$ e $w$
	        	    \STATE marque $w$
		            \STATE insira $w$ em $F$
		         \ELSE
				\IF {$w \in F$}
		        	    \STATE visite aresta entre v e w
	         		\ENDIF
			\ENDIF
		\ENDFOR
      		\STATE retira v de F
      \ENDWHILE
 	\end{algorithmic}
\label{algoritmo2} 
\end{small}
\end{algorithm}


\subsection{Solução por Floyd Warshall}

O algoritmo de {\it Floyd Warshall} é um método usado no cálculo do caminho mais curto entre todos os pares de vértices em um grafo orientado (com direção) e valorado (com peso) \cite{fwa}.
O algoritmo pode ser adaptado para grafos não orientados e não valorados (replicando as arestas direcionadas e atribuindo pesos iguais para as arestas).

O algoritmo recebe como entrada uma matriz de adjacência que representa o grafo. 
No caso do trabalho prático, uma matriz é construida, atribuindo-se o valor 1 para posições representando arestas existentes e {\it infinito} para as demais.
O valor de um caminho entre dois vértices é a soma dos valores de todas as arestas ao longo desse caminho. 
O método calcula, para cada par de vértices, o menor de todos os caminhos entre os vértices.

O algoritmo de {\it Floyd Warshall} é baseado no conceito de {\it Programação Dinâmica}.
O cálculo de um caminho mínimo entre dois vértices é executado uma única vez.
Sempre que um caminho já calculado faz parte de um caminho para o qual o cálculo está sendo executado, o valor já obtido é reaproveitado.

O algoritmo \ref{algoritmo3} resume o que foi explicado.

\begin{algorithm}[!h]
\begin{small}
 \caption{Algoritmo de {\it Floyd Warshall}}
 	\begin{algorithmic}[1]
        \STATE inicializa a matriz ($n x n$) $path$ com 1 para arestas existentes e $INF$ caso contrário
	\FOR{$k=0$ \TO $n$}
		\FOR{$i=0$ \TO $n$}
			\FOR{$j=0$ \TO $n$}
				\STATE $sum=path[i][k] + path[k][j]$
	      			\STATE $path[i][j] = min(path[i][j], sum)$
			\ENDFOR
		\ENDFOR
	\ENDFOR
 	\end{algorithmic}
\label{algoritmo3} 
\end{small}
\end{algorithm}


\subsection{Complexidade}

Considerando um grafo $G$ com $v = |V|$ vértices e $n = |E|$ arestas.
A solução proposta envolve um ciclo de iterações em que arestas são removidas até que o grafo possa ser dividido em $k$ comunidades.
A operação de selecionar e remover a aresta de maior centralidade, tem custo, no máximo $O(n)$ (considerando que os valores de centralidade já são conhecidos).

A operação de cálculo da centralidade de todas as arestas do grafo depende do algoritmo implementado para obtenção dos caminhos mínimos.

Para a {\bf Solução por Breadth First Search}, a complexidade do cálculo do caminho mínimo é $O(|E| + |V|)$, já que todos os vértices e arestas são explorados, no pior caso.
Dependendo da densidade do grafo, esta complexidade pode variar de $O(|V|)$ para $O(|V|^2)$. Este procedimento é executado variando o vértice inicial, para cada vértice do grafo.
Portanto, a complexidade de se calcular a centralidade por esta solução é, no pior caso, $O(|V|^3)$.

Para a {\bf Solução por Floyd Warshall}, todos os $v^2$ caminhos mínimos (para todo $i$ e $j$) são obtidos por operações constantes executadas
em três {\it loops} aninhados, que variam de 1 a $n$ (ver algoritmo \ref{algoritmo3}). Portanto, a complexidade do cálculo é cúbica $O(|V|^3)$. 

Por fim, resta a operação de verificar quantas comunidades existem e de identificá-las.
Para isso, é feita uma busca em largura no grafo. Quando um vértice é visitado, este é marcado.
Se ao fim da busca, algum vértice não recebeu a marcação, significa que este faz parte de outra comunidade.
O processo é repetido para o vértice desmarcado, e assim, sucessivamente, até que todos os vértices estejam marcado e as comunidades identificadas.
O custo de efetuar este procedimento é $O(|E|+|V|)$, já que todos os vértices e arestas são visitados.

A complexidade do algoritmo todo corresponde ao custo (que prevalece) de se computar os valores de centralidade para todas as arestas, que é $O(|V|^3)$.



\section{Implementação}

A solução para o problema proposto foi implementada na linguagem {\it Java} e plataforma {\it Linux}. Os arquivos do diretório {\it src} contêm o código da implementação. 

Antes de executar os código, é necessário compilá-los, pelo comando:
\begin{small}
\begin{verbatim}
                javac -d ./bin *.java
\end{verbatim}
\end{small}
Alternativamente, pode ser usado o programa {\it Makefile}. O seguinte comando executa a compilação:
\begin{small}
\begin{verbatim}
                make
\end{verbatim}
\end{small}
Os arquivos compilados (com extensão {\it .class} serão gerados no diretório {\it bin}).

Para executar o programa, é necessário passar os seguintes parâmetros:
\begin{itemize}
 \item arquivo contendo as arestas do grafo
 \item número de {\it comunidades} que serão obtidas
 \item número de vértices
 \item algoritmo usado:
  \begin{itemize}
      \item b: Breadth First Search
      \item f: Floyd Warshall
  \end{itemize}
\end{itemize}
A execução é feita pelo comando (no diretório {\it bin}):
\begin{small}
\begin{verbatim}
    java Main <arquivo_arestas> <num_comunidades> 
	      <num_vertices> <algoritmo: b|f>
\end{verbatim}
\end{small}

O código que implementa a solução foi compilado e executado corretamente na máquina {\it jaguar}, do departamento de computação.

\section{Análise Experimental}

Para verificar o comportamento dos algoritmos, foram realizados alguns experimentos. 
Foi usado um {\it script} gerador de entradas aleatórias segundo o padrão definido na especificação (o {\it script} foi disponibilizado pelos monitores da disciplina).
Foram geradas entradas variando o número de vértices (e, consequentemente, o número de arestas) e fixando o número de {\it comunidades} geradas (em 10).

Primeiramente, gerou-se um grafo denso, a partir da função de distribuição de arestas $|E| = \frac{|V|^2}{1.5})$. 
O número de vértices foi variado de 10 à 100. O gráfico seguinte apresenta os resultados obtidos para as duas soluções:

\begin{center}
\includegraphics{results.png}
\end{center} 

Outro experimento executado foi a geração de um grafo esparso, a partir de uma função de distribuição seguindo uma {\it power law}.
O número de vértices foi variado de 100 à 300. O gráfico seguinte apresenta os resultados obtidos para as duas soluções:

\begin{center}
\includegraphics{results2.png}
\end{center} 

Pela observação dos dois gráficos, é fácil constatar que o algoritmo de {\it Floyd Warshall} foi mais eficiente para todos os testes.
Uma justificativa para isso é que o algoritmo BFS não possui a vantagem do reaproveitamento de cálculos, concedida pela programação dinâmica.

Apesar das diferenças de tempo de execução, o comportamento das curvas dos dois algoritmos foi semelhante.
Nota-se que as curvas são semelhantes a graficos originados de funções cúbicas. O que foi sugerido pelo cálculo de complexidade das soluções.

Outra observação importante é que a densidade do gráfico tem muita influência no tempo de execução dos algoritmos.
Os métodos gastaram, em média, 1000 segundos para executarem sobre um gráfico denso com 100 vértices.
Porém, para um grafo esparso com 100 vértices, a execução foi quase que imediata.

\begin{small}
\bibliographystyle{plain}
\bibliography{doc}
\end{small}

\end{document}
